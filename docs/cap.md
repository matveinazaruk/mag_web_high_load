Для начала хотел бы описать примерный сценарий использования сервиса. 

Есть два типа пользователей:

- администратор
- рядовой пользователь


Сценарий Администратора
-----------------------

Есть какой-либо администратор периодически выкладывает билеты на различные мероприятия (кино, концерты).  
Это событие происходит не очень часто по сравнению с просмотром билетов. Причем в общем случае - один раз для всего события. 


Сценарий Рядового пользователя
-------------------------------

Примерно постоянный поток рядовых пользователей просматривает свободные билеты на различные мероприятия.  
Как действует средний пользователь (я):

1. просматривает несколько различный событий выбирая интересующее
2. получает список билетов и выбирает из него несколько
3. бронирование билета (перевод билета в статус pending)
4. оплата на стороннем сервисе
5. закрепление билета за пользователем (перевод в статус sold)

Ожидается, что пока билет в статусе pending - никто другой не может его занять.  
Также можно предположить, что пользователь будет искать события либо схожие по типу, либо близкие по дате (пока не придумал, как это может помочь).


Анализ операций
----------------

У нас есть два типа объектов:

- событие
- билет

Причем, отошение событий к билетам: 1 to m.  
Попробуем проанализировать какие операции будут примерно происходить для каждого типа объектов.


### События

Можно заметить, что операции создания событий происходят довольно редко, по сравнению с и чтением (событие читается хотя бы один раз за один купленный билет).  
Их может создавать только администратор, и делает он это один раз для каждого события. 
Исходя из модели, обновление событий должно происходить при каждой покупке билетов, чтобы актуализировать количество свободных билетов. 
Будем считать, что операция обнволения события просиходит примерно столько же раз, сколько и покупка билетов на данное событие.  
Если считать, что пользователь покупает билет после просмотра нескольких событий - то операция изменения будет в несколько раз меньше операций чтения.

### Билеты

Исходя из придуманного сценария работы пользоватя на каждую покупку билета пользователь просматривает несколько событий.  
Т.е. читает все билеты нескольких событий. Отсюда следует что операций изменения билета намного меньше, чем операций чтения.  


CAP
----------------

Насколько я вижу, главное правило для подобного сервиса - чтобы не было коллизий относительно занятого билета.  
Т.е. если я уже начал покупать его, и купил - то желательно, чтобы больше никто не пытался это сделать.  
Поэтому в сервисе должна присутствовать consistency для отдельного билета.  
Относительно всего события данные могут приходить немного позднее, это не критично. Пользователю можно показать сообщение - что билет уже заняли.  

Т.е. нам нужна consistency по одельному билету, а для всей системы событий - availability.  
Пользователям важно знать какие вообще есть события, что иметь возможность выбрать наиболее подходящее. 
И им нужно видеть близкое к реальному количество свободных билетов. 

Можно предложить следующую структуру:

Т.к. операции записи происходят реже - то можно их отправлять на какую-нибудь master ноду, единственную, которая может делать изменения в записях.  
Тогда при попытке пользователя купить билет - он сразу узнает, занят он или нет (т.к. данная нода содержит самые актуальные данные).
Далее данные могут рассылаться по остальным нодам, с некоторым опозданием.

Получается, есть два варианта, когда пользователь видит неактуальные данные в нашей системе: 

- покупки билетов происходят **часто** (какое важное событие) - в этом случае данные, которые видит пользователь быстро становятся не актуальными (не зависимо от задержки обновления)
- покупки происходят **редко** (обычное событие), но кто-то одновременно купил какой-то билет - в этом случае данные, которые видит пользователь обновятся и придут в актуально состояние довольно быстро

Оба этих варианта нас вполне устраивают.

Также, чтобы уменьшить нагрузку на записи, администраторам монжо разрешить создание событий в определенное время, когда происходить меньше всего покупок билетов.



